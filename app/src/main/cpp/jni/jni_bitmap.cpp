/* DO NOT EDIT THIS FILE - it is machine generated */
#include <base.h>
/* Header for class com_example_ndk_jni_JniBitmap */
#include <android/bitmap.h>
#include <cstring>

#ifndef _Included_com_example_ndk_jni_JniBitmap
#define _Included_com_example_ndk_jni_JniBitmap
#ifdef __cplusplus
extern "C" {
#endif

jobject generateBitmap(JNIEnv *env, int newWidth, int newHeight) {

    jclass config_class = env->FindClass("android/graphics/Bitmap$Config");

    jmethodID value_of_method = env->GetStaticMethodID(config_class, "valueOf",
                                                       "(Ljava/lang/String;)Landroid/graphics/Bitmap/Config;");

    jstring str = env->NewStringUTF("ARGB_8888");

    jobject config = env->CallStaticObjectMethod(config_class, value_of_method, str);

    // 获取 bitmap class
    jclass bitmap_clazz = env->FindClass("android/graphics/Bitmap");
    jmethodID create_bitmap = env->GetStaticMethodID(bitmap_clazz, "createBitmap",
                                                     "(IILandroid/graphics/Bitmap/Config;)Landroid/graphics/Bitmap;");

    jobject newBitmap = env->CallStaticObjectMethod(bitmap_clazz, create_bitmap, newWidth, newHeight, config);

    // // 获取 bitmap constructor
    // jmethodID constructor_method = env->GetMethodID(cls, "<init>", "()V");
    //
    // // 调用 constructor， 生成 bitmap 对象
    // jobject bitmap = env->NewObject(cls, constructor_method);
    //
    // // 获取 setWidth、setHeight 方法
    // jmethodID width = env->GetMethodID(cls, "setWidth", "(I)V");
    // jmethodID height = env->GetMethodID(cls, "setHeight", "(I)V");
    //
    // // 调用 setWidth、setHeight 方法， 设置对应值
    // env->CallVoidMethod(bitmap, width, newWidth);
    //
    // env->CallVoidMethod(bitmap, height, newHeight);

    // 返回对象
    return newBitmap;
}
/*
 * Class:     com_example_ndk_jni_JniBitmap
 * Method:    callNativeMirrorBitmap
 * Signature: (Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;
 */
JNIEXPORT jobject JNICALL Java_com_example_ndk_jni_JniBitmap_callNativeMirrorBitmap2
        (JNIEnv *env, jobject clazz, jobject bitmap) {
    AndroidBitmapInfo bitmapInfo;
    AndroidBitmap_getInfo(env, bitmap, &bitmapInfo);

    LOGE("width is %d", bitmapInfo.width);
    LOGE("height is %d", bitmapInfo.height);

    void *bitmapPixels;

    AndroidBitmap_lockPixels(env, bitmap, (void **) &bitmapPixels);

    uint32_t newWidth = bitmapInfo.width;
    uint32_t newHeight = bitmapInfo.height;

    auto *newBitmapPixels = new uint32_t[newWidth * newHeight];

    // 此处转换有问题
    int whereToGet = 0;
    for (int y = 0; y < newHeight; ++y) {
        for (int x = newWidth - 1; x >= 0; x--) {
            uint32_t pixel = ((uint32_t *) bitmapPixels)[whereToGet++];
            newBitmapPixels[newWidth * y + x] = pixel;
        }
    }

    AndroidBitmap_unlockPixels(env, bitmap);

    jobject newBitmap = generateBitmap(env, newWidth, newHeight);

    void *resultBitmapPixels;

    AndroidBitmap_lockPixels(env, newBitmap, &resultBitmapPixels);

    // void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。
    memcpy((uint32_t *) resultBitmapPixels, newBitmapPixels, sizeof(uint32_t) * newWidth * newHeight);

    AndroidBitmap_unlockPixels(env, newBitmap);

    delete[] newBitmapPixels;

    return newBitmap;
}

JNIEXPORT jobject JNICALL Java_com_example_ndk_jni_JniBitmap_callNativeMirrorBitmap
        (JNIEnv *env, jobject clazz, jobject bitmap) {
    jclass matrix_clazz = env->FindClass("android/graphics/Matrix");

    jmethodID matrix_constructor = env->GetMethodID(matrix_clazz, "<init>", "()V");

    jobject matrix = env->NewObject(matrix_clazz, matrix_constructor);

    jmethodID scale_method = env->GetMethodID(matrix_clazz, "setScale", "(FF)V");
    env->CallVoidMethod(matrix, scale_method, -1.0f, 1.0f);

    AndroidBitmapInfo bitmapInfo;
    AndroidBitmap_getInfo(env, bitmap, &bitmapInfo);

    LOGE("width is %d", bitmapInfo.width);
    LOGE("height is %d", bitmapInfo.height);

    jclass bitmap_clazz = env->FindClass("android/graphics/Bitmap");
    jmethodID create_bitmap = env->GetStaticMethodID(bitmap_clazz, "createBitmap",
                                                     "(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;");

    jint width = bitmapInfo.width;
    jint height = bitmapInfo.height;

    return env->CallStaticObjectMethod(bitmap_clazz, create_bitmap, bitmap, 0, 0, width, height, matrix, true);
}

JNIEXPORT void JNICALL Java_com_example_ndk_jni_JniBitmap_getBinaryBitmap
        (JNIEnv *env, jobject jobj, jobject jBitmap) {
    int result;
    // 获取源Bitmap相关信息：宽、高等
    AndroidBitmapInfo sourceInfo;
    result = AndroidBitmap_getInfo(env, jBitmap, &sourceInfo);
    if (result < 0) {
        return;
    }
    // 获取源Bitmap像素数据 这里用的是32位的int类型 argb每个8位
    uint32_t *sourceData;
    //锁定像素的地址（不锁定的话地址可能会发生改变）
    result = AndroidBitmap_lockPixels(env, jBitmap, (void **) &sourceData);
    if (result < 0) {
        return;
    }
    // 遍历各个像素点
    int color;
    int red, green, blue, alpha;
    int width = sourceInfo.width;
    int height = sourceInfo.height;
    int w, h;
    for (h = 0; h < height; h++) {
        for (w = 0; w < width; w++) {
            color = sourceData[h * width + w];
            alpha = color & 0xff000000;
            red = (color & 0x00ff0000) >> 16;
            green = (color & 0x0000ff00) >> 8;
            blue = color & 0x000000ff;
            // 通过加权平均算法,计算出最佳像素值
            color = red * 0.3 + green * 0.59 + blue * 0.11;
            if (color <= 95) {
                color = 0;
            } else {
                color = 255;
            }
            sourceData[h * width + w] = alpha | (color << 16) | (color << 8) | color;
        }
    }
    AndroidBitmap_unlockPixels(env, jBitmap);
}

#ifdef __cplusplus
}
#endif
#endif
